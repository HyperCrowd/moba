<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Simple MOBA Game</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.85.0/phaser.min.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <script>
    const config = {
      type: Phaser.AUTO,
      width: window.innerWidth,
      height: window.innerHeight,
      scene: {
        preload: preload,
        create: create,
        update: update
      },
      physics: {
        default: 'arcade',
        arcade: {
          gravity: { y: 0 },
          debug: false
        }
      }
    };

    const game = new Phaser.Game(config)
    const PLAYER_X = 500
    const PLAYER_Y = 3800
    const PLAYER_WIDTH = 64
    const PLAYER_HEIGHT = 64
    const MAP_WIDTH = 4480
    const MAP_HEIGHT = 4480
    const PLAYER_SPEED = 200
    const FIREBALL_RANGE = 400
    const FIREBALL_SPEED = 600

    let player;
    let cursors;
    let map;
    let maskData;
    let collidingLeft = false;
    let collidingRight = false;
    let collidingTop = false;
    let collidingBottom = false;
    const fireballs = []

    /**
     * 
     */
    function preload() {
      // Load the map image and player image
      this.load.image('map', 'assets/map.jpg'); // Replace with your map image path
      this.load.image('mask', 'assets/mask_map.png'); // Load the mask image
      this.load.image('player', 'assets/player.png'); // Replace with your player image path
      this.load.image('fireball', 'assets/fireball.png');
    }

    /**
     * 
     */
    function create() {
      // Create the map
      map = this.add.image(0, 0, 'map').setOrigin(0, 0);
      map.setDisplaySize(MAP_WIDTH, MAP_HEIGHT); // Adjust size based on your map dimensions

      // Create the player
      player = this.physics.add.sprite(PLAYER_X, PLAYER_Y, 'player');
      player.setOrigin(0.5, 0.5)
      player.setCollideWorldBounds(true);
      this.physics.world.setBounds(0, 0, MAP_WIDTH, MAP_HEIGHT);

      // Camera follows the player
      this.cameras.main.startFollow(player);
      this.cameras.main.setBounds(0, 0, MAP_WIDTH, MAP_HEIGHT);

      // Load the mask texture
      const maskImage = this.textures.get('mask').getSourceImage();
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d', { willReadFrequently: true });

      // Set canvas size to mask image size
      canvas.width = maskImage.width;
      canvas.height = maskImage.height;
      context.drawImage(maskImage, 0, 0);

      // Get image data
      const imageData = context.getImageData(
        -(PLAYER_WIDTH / 2),
        -(PLAYER_HEIGHT / 2),
        canvas.width,
        canvas.height
      );
      maskData = imageData.data; // Store the pixel data

      // Input
      cursors = this.input.keyboard.createCursorKeys();
      this.input.keyboard.addKey('W');
      this.input.keyboard.addKey('A');
      this.input.keyboard.addKey('S');
      this.input.keyboard.addKey('D');

      // Fireball
      this.input.on('pointerdown', (pointer) => {
        const startX = player.x
        const startY = player.y
        const targetX = pointer.worldX
        const targetY = pointer.worldY

        const fireball = this.physics.add.sprite(startX, startY, 'fireball'); // Load your fireball image
        fireball.setOrigin(0.5, 0.5);
        
        // Calculate direction and distance
        const dx = targetX - startX;
        const dy = targetY - startY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Normalize the direction
        fireball.velocityX = (dx / distance) * FIREBALL_SPEED; // Speed of the fireball
        fireball.velocityY = (dy / distance) * FIREBALL_SPEED;

        // Store the initial position
        fireball.originX = startX;
        fireball.originY = startY;

        fireballs.push(fireball);
      });
    }

    /**
     * 
     */
    function update() {
      fireballs.forEach((fireball, index) => {
        fireball.x += fireball.velocityX * (1 / 60); // Move the fireball
        fireball.y += fireball.velocityY * (1 / 60); // Move the fireball

        // Calculate the distance from the origin
        const distance = Phaser.Math.Distance.Between(fireball.originX, fireball.originY, fireball.x, fireball.y);

        // Fade out the fireball
        const alpha = Math.max(0, 1 - (distance / FIREBALL_RANGE));
        fireball.setAlpha(alpha);

        // Destroy the fireball if it exceeds 100 pixels from the origin
        if (distance > FIREBALL_RANGE) {
          fireball.destroy();
          fireballs.splice(index, 1); // Remove from the array
        }
      });

      const speed = PLAYER_SPEED;

      // Reset desired velocities
      let desiredVelocityX = 0;
      let desiredVelocityY = 0;

      // Calculate desired velocity based on input and collision state
      if ((cursors.left.isDown || this.input.keyboard.checkDown(this.input.keyboard.addKey('A'), 0)) && !collidingLeft) {
        desiredVelocityX = -speed;
      }
      
      if ((cursors.right.isDown || this.input.keyboard.checkDown(this.input.keyboard.addKey('D'), 0)) && !collidingRight) {
        desiredVelocityX = speed;
      }

      if ((cursors.up.isDown || this.input.keyboard.checkDown(this.input.keyboard.addKey('W'), 0)) && !collidingTop) {
        desiredVelocityY = -speed;
      }
      
      if ((cursors.down.isDown || this.input.keyboard.checkDown(this.input.keyboard.addKey('S'), 0)) && !collidingBottom) {
        desiredVelocityY = speed;
      }

      // Check for potential collisions with the desired velocity
      const newX = player.x + desiredVelocityX / 30;
      const newY = player.y + desiredVelocityY / 30;

      // Check for collisions with the player's pixel area
      const collisions = checkPixelCollision(newX, newY, PLAYER_WIDTH, PLAYER_HEIGHT);

      // Set the player's velocity based on the collision results
      if (collisions.collidingLeft) {
        desiredVelocityX = 0;
      }
      if (collisions.collidingRight) {
        desiredVelocityX = 0;
      }
      if (collisions.collidingTop) {
        desiredVelocityY = 0;
      }
      if (collisions.collidingBottom) {
        desiredVelocityY = 0;
      }

      // Apply the calculated velocities
      player.setVelocityX(desiredVelocityX);
      player.setVelocityY(desiredVelocityY);

      // Update the collision flags based on the latest checks
      collidingLeft = collisions.collidingLeft;
      collidingRight = collisions.collidingRight;
      collidingTop = collisions.collidingTop;
      collidingBottom = collisions.collidingBottom;
    }

    /**
     * 
     */
    function checkPixelCollision(x, y, width, height) {
      const maskWidth = map.displayWidth;
      const maskHeight = map.displayHeight;

      let collidingLeft = false;
      let collidingRight = false;
      let collidingTop = false;
      let collidingBottom = false;

      // Loop through each pixel in the player's bounding box
      for (let pixelY = 0; pixelY < height; pixelY++) {
        for (let pixelX = 0; pixelX < width; pixelX++) {
          const checkX = Math.floor(x) + pixelX;
          const checkY = Math.floor(y) + pixelY;

          // Check bounds
          if (checkX >= 0 && checkX < maskWidth && checkY >= 0 && checkY < maskHeight) {
            const index = (checkY * maskWidth + checkX) * 4;
            const r = maskData[index];
            const g = maskData[index + 1];
            const b = maskData[index + 2];

            // Check for a collision (black pixel)
            if (r === 0 && g === 0 && b === 0) {
              // Collision detected; determine which side
              if (pixelX === 0) collidingLeft = true; // Left edge collision
              if (pixelX === width - 1) collidingRight = true; // Right edge collision
              if (pixelY === 0) collidingTop = true; // Top edge collision
              if (pixelY === height - 1) collidingBottom = true; // Bottom edge collision
            }
          }
        }
      }

      return { collidingLeft, collidingRight, collidingTop, collidingBottom };
    }

    /**
     * 
     */
    window.addEventListener('resize', () => {
      game.scale.resize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
